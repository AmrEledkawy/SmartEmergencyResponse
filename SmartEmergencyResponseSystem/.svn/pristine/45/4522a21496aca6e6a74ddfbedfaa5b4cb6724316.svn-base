classdef Simulator < handle
    %SIMULATOR Summary of this class goes here
    %   Detailed explanation goes here
    
    properties (SetAccess = private, GetAccess = private)
        GroundVehicles
        Quadcopters
        Requests
        simdt
        
        GVudp
        QCudp
        stepTimer
    end
    
    methods
        function obj = Simulator(groundVehicleManager,...
                                 quadCopterManager,...
                                 requestManager,...
                                 simdt)
            obj.GroundVehicles = groundVehicleManager;
            obj.Quadcopters = quadCopterManager;
            obj.Requests = requestManager;
            obj.simdt = simdt;
            obj.startUDP();
            
            obj.stepTimer = timer('ExecutionMode','fixedRate','Period',obj.simdt);
        end
        
        function startUDP(obj)
            GVport = 4012;
            QCport = 4013;                        
            
            GeIP = '127.0.0.1';
            
            obj.GVudp = udp(GeIP,GVport+30,'LocalPort',GVport);
            obj.QCudp = udp(GeIP,QCport+30,'LocalPort',QCport); 
            
            fopen(obj.GVudp);
            fopen(obj.QCudp);
            
        end
        
        function start(obj)
            obj.setGVDependency();
            set(obj.stepTimer,'TimerFcn',@(~,~)obj.step());
            start(obj.stepTimer);
        end
        
        function stop(obj)
            stop(obj.stepTimer)
        end    
    end
    
    methods (Access = private)
        function step(obj)
            obj.simGroundVehicles();
            obj.simQuadCopters();
            drawnow
        end
        
        function setGVDependency(obj)

            for vehicle = obj.GroundVehicles.getVehicles()
                vehicle.isWaitingForQuad = 0;
            end
            
            for quadcopter = obj.Quadcopters.getVehicles()
                for i = 1:numel(quadcopter.waypointTargets)
                    mc = metaclass(quadcopter.waypointTargets{i});
                    if strcmp(mc.Name, 'GroundVehicle')
                        quadcopter.waypointTargets{i}.isWaitingForQuad = ...
                            quadcopter.waypointTargets{i}.isWaitingForQuad + 1;
                    end
                end
            end
        end

        function simQuadCopters(obj)
            quads = obj.Quadcopters.getVehicles();
            data = zeros(numel(quads),6);
            idx = 0;
            % Loop over all Quadcopters
            for quadcopter = quads
                idx = idx + 1;
                
                plannedRoute = quadcopter.getRoute();

                if (size(plannedRoute,1)>1) % Keep navigating while there is at least one more target
                    targetLoc = plannedRoute(2,:);
                    speed = quadcopter.speed;
                    % Check if quad is close enough to the waypoint to reach in one step
                    if (norm(quadcopter.location - targetLoc)<speed*obj.simdt)
                        quadcopter.charge = quadcopter.charge-norm(quadcopter.location-targetLoc)./QuadCopter.maxRange;
                        quadcopter.location = targetLoc;    % In this step quad reaches the waypoint
                        quadcopter.cargo = quadcopter.loadouts{2};
                        currentTarget = quadcopter.waypointTargets{2};
                        mc = metaclass(currentTarget);
                        if (strcmp(mc.Name,'Request'))
                            idx = find(obj.Requests.getRequests() == currentTarget,1,'last');
                            obj.Requests.removeRequest(idx);
                        elseif strcmp(mc.Name,'GroundVehicle')
                            currentTarget.isWaitingForQuad = ...
                                currentTarget.isWaitingForQuad - 1;
                        end
                        quadcopter.waypointReached();         % It covered one more waypoint

                        % Also check if Quad is done with it's route
                        % and needs to ride on the GV
                        if (size(quadcopter.getRoute(),1)==1) % This is the last waypoint
                            quadcopter.waypointTargets{1}.addCargo(quadcopter);
                            quadcopter.deactivate;
                        end

                    else
                        % Move the quad by one time step in the correct direction
                        heading = targetLoc - quadcopter.location;
                        quadcopter.location = quadcopter.location + speed*obj.simdt*heading/norm(heading);
                        quadcopter.charge = quadcopter.charge - speed*obj.simdt/QuadCopter.maxRange;
                    end                  
                    head = targetLoc-quadcopter.location;
                    data(idx,:) = [quadcopter.location 40 atan2d(head(1),head(2)) 0 0];
                end                
            end
            fwrite(obj.QCudp,data(:));
        end
        
        function simGroundVehicles(obj)
            groundvehicles = obj.GroundVehicles.getVehicles();
            data = zeros(numel(groundvehicles),6);
            idx = 0;
            % Loop over all ground Vehicles and simulate
            for groundVehicle = groundvehicles
                idx = idx + 1;
                plannedRoute = groundVehicle.getRoute();
                
                if (size(plannedRoute,1)>1 && groundVehicle.isWaitingForQuad == 0) % Keep navigating until the GV reaches the final waypoint
                    targetLoc = plannedRoute(2,:);
                    speed = groundVehicle.speed;
                    % Check if GV is close enough to the waypoint to reach in one step
                    if (norm(groundVehicle.location - targetLoc)<speed*obj.simdt)
                        groundVehicle.moveTo(targetLoc); % In this step quad reaches the waypoint
                        groundVehicle.waypointReached();
                    else
                        % Move the quad by one time step in the correct direction
                        heading = targetLoc - groundVehicle.location;
                        groundVehicle.moveTo(groundVehicle.location + speed*obj.simdt*heading/norm(heading));
                    end
                    head = targetLoc-groundVehicle.location;
                    data(idx,:) = [groundVehicle.location 0 atan2d(head(1),head(2)) 0 0]; 
                end
            end
            fwrite(obj.GVudp,data(:));
        end
        
    end
    
end

